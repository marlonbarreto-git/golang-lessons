// Package main - Chapter 069: Code Generation
// Go tiene excelentes herramientas de generación de código. Aprenderás
// go generate, stringer, mockgen, protoc, sqlc y AST manipulation.
package main

import (
	"os"
	"fmt"
)

func main() {
	fmt.Println("=== CODE GENERATION EN GO ===")

	// ============================================
	// GO GENERATE BASICS
	// ============================================
	fmt.Println("\n--- go generate ---")
	fmt.Println(`
go generate escanea archivos .go buscando directivas especiales:

//go:generate command args...

COMANDOS COMUNES:
- stringer: generar String() para enums
- mockgen: generar mocks
- protoc: generar código protobuf
- sqlc: generar queries SQL type-safe

EJECUTAR:
go generate ./...          # Todo el proyecto
go generate ./pkg/models   # Solo ese paquete
go generate -x ./...       # Verbose (mostrar comandos)

EJEMPLO BÁSICO:

// models.go
package models

//go:generate echo "Generating models..."

type User struct {
    ID   int
    Name string
}

USAR VARIABLES:

//go:generate echo $GOFILE $GOLINE $GOPACKAGE $DOLLAR

$GOFILE    - Nombre del archivo actual
$GOPACKAGE - Nombre del paquete actual
$GOLINE    - Número de línea
$DOLLAR    - Símbolo $

MÚLTIPLES COMANDOS:

//go:generate echo "Step 1"
//go:generate echo "Step 2"
//go:generate echo "Step 3"

CONDICIONAL (con script):

//go:generate sh -c "[ ! -f generated.go ] && echo 'First time' || echo 'Already exists'"

.GITIGNORE para generados:

*_gen.go
*_generated.go
mock_*.go
*.pb.go`)
	// ============================================
	// STRINGER
	// ============================================
	fmt.Println("\n--- stringer Tool ---")
	fmt.Println(`
INSTALACIÓN:
go install golang.org/x/tools/cmd/stringer@latest

Genera método String() para tipos enumerados.

EJEMPLO:

// status.go
package order

//go:generate stringer -type=Status -linecomment

type Status int

const (
    StatusPending   Status = iota  // pending
    StatusConfirmed                // confirmed
    StatusShipped                  // shipped
    StatusDelivered                // delivered
    StatusCancelled                // cancelled
)

// Generará: status_string.go

EJECUTAR:
go generate ./...

CÓDIGO GENERADO (status_string.go):

// Code generated by "stringer -type=Status -linecomment"; DO NOT EDIT.

package order

import "strconv"

func _() {
    var x [1]struct{}
    _ = x[StatusPending-0]
    _ = x[StatusConfirmed-1]
    _ = x[StatusShipped-2]
    _ = x[StatusDelivered-3]
    _ = x[StatusCancelled-4]
}

const _Status_name = "pendingconfirmedshippeddeliveredcancelled"

var _Status_index = [...]uint8{0, 7, 16, 23, 32, 41}

func (i Status) String() string {
    if i < 0 || i >= Status(len(_Status_index)-1) {
        return "Status(" + strconv.FormatInt(int64(i), 10) + ")"
    }
    return _Status_name[_Status_index[i]:_Status_index[i+1]]
}

USO:

status := StatusPending
fmt.Println(status)  // Output: pending

json.Marshal(status)  // "pending"

SIN LINECOMMENT:

//go:generate stringer -type=Color

type Color int

const (
    Red Color = iota
    Green
    Blue
)

// fmt.Println(Red) → "Red"

CON OUTPUT:

//go:generate stringer -type=Status -output=status_strings.go

MÚLTIPLES TIPOS:

//go:generate stringer -type=Status,Priority,Color

TRIMPREFIX:

//go:generate stringer -type=Status -trimprefix=Status

type Status int
const (
    StatusPending Status = iota
    StatusActive
)

// Genera: "Pending", "Active" (sin "Status")`)
	// ============================================
	// MOCKGEN
	// ============================================
	fmt.Println("\n--- mockgen (gomock) ---")
	os.Stdout.WriteString(`
INSTALACIÓN:
go install go.uber.org/mock/mockgen@latest

Genera mocks para interfaces.

MODO SOURCE:

// user_service.go
package service

type UserService interface {
    GetUser(id string) (*User, error)
    CreateUser(user *User) error
    UpdateUser(user *User) error
    DeleteUser(id string) error
}

//go:generate mockgen -source=user_service.go -destination=mock_user_service.go -package=service

MODO REFLECT:

//go:generate mockgen -destination=mock_database.go -package=mocks github.com/myapp/database Database

USAR EL MOCK:

import (
    "testing"
    "go.uber.org/mock/gomock"
)

func TestUserHandler(t *testing.T) {
    ctrl := gomock.NewController(t)
    defer ctrl.Finish()

    mockService := NewMockUserService(ctrl)

    // Expectativas
    mockService.EXPECT().
        GetUser("123").
        Return(&User{ID: "123", Name: "Alice"}, nil).
        Times(1)

    // Test
    handler := NewUserHandler(mockService)
    user, err := handler.GetUserByID("123")

    if err != nil {
        t.Errorf("unexpected error: %v", err)
    }
    if user.Name != "Alice" {
        t.Errorf("expected Alice, got %s", user.Name)
    }
}

MATCHERS:

mockService.EXPECT().
    CreateUser(gomock.Any()).
    Return(nil)

mockService.EXPECT().
    CreateUser(gomock.Not(gomock.Nil())).
    Return(nil)

mockService.EXPECT().
    GetUser(gomock.Eq("123")).
    Return(user, nil)

CUSTOM MATCHER:

type userMatcher struct {
    name string
}

func (m *userMatcher) Matches(x any) bool {
    user, ok := x.(*User)
    return ok && user.Name == m.name
}

func (m *userMatcher) String() string {
    return "user with name " + m.name
}

mockService.EXPECT().
    CreateUser(&userMatcher{name: "Alice"}).
    Return(nil)

DO/DOANDRETURN:

mockService.EXPECT().
    CreateUser(gomock.Any()).
    Do(func(user *User) {
        fmt.Printf("Creating user: %s\n", user.Name)
    })

mockService.EXPECT().
    GetUser(gomock.Any()).
    DoAndReturn(func(id string) (*User, error) {
        return &User{ID: id, Name: "Generated"}, nil
    })
`)

	// ============================================
	// PROTOC (PROTOCOL BUFFERS)
	// ============================================
	fmt.Println("\n--- protoc (Protocol Buffers) ---")
	fmt.Println(`
INSTALACIÓN:
# protoc compiler
brew install protobuf  # macOS
apt install protobuf-compiler  # Linux

# Go plugins
go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest

DEFINICIÓN .proto:

// user.proto
syntax = "proto3";

package user;

option go_package = "github.com/myapp/proto/user";

message User {
  string id = 1;
  string name = 2;
  string email = 3;
  repeated string roles = 4;
  int64 created_at = 5;
}

message GetUserRequest {
  string id = 1;
}

message GetUserResponse {
  User user = 1;
}

service UserService {
  rpc GetUser(GetUserRequest) returns (GetUserResponse);
  rpc CreateUser(User) returns (User);
  rpc StreamUsers(stream User) returns (User);
}

GENERAR CÓDIGO:

//go:generate protoc --go_out=. --go_opt=paths=source_relative \
//    --go-grpc_out=. --go-grpc_opt=paths=source_relative \
//    user.proto

O con Makefile:

.PHONY: proto
proto:
	protoc --go_out=. --go_opt=paths=source_relative \
		--go-grpc_out=. --go-grpc_opt=paths=source_relative \
		proto/*.proto

USAR CÓDIGO GENERADO:

import pb "github.com/myapp/proto/user"

user := &pb.User{
    Id:    "123",
    Name:  "Alice",
    Email: "alice@example.com",
    Roles: []string{"admin", "user"},
}

// Serializar
data, _ := proto.Marshal(user)

// Deserializar
var user2 pb.User
proto.Unmarshal(data, &user2)

BUF (Alternativa moderna):

# buf.yaml
version: v1
breaking:
  use:
    - FILE
lint:
  use:
    - DEFAULT

# buf.gen.yaml
version: v1
plugins:
  - plugin: go
    out: gen
    opt: paths=source_relative
  - plugin: go-grpc
    out: gen
    opt: paths=source_relative

# Generar
buf generate`)
	// ============================================
	// SQLC
	// ============================================
	fmt.Println("\n--- sqlc (Type-safe SQL) ---")
	fmt.Println(`
INSTALACIÓN:
go install github.com/sqlc-dev/sqlc/cmd/sqlc@latest

Genera código Go type-safe desde queries SQL.

CONFIGURACIÓN (sqlc.yaml):

version: "2"
sql:
  - engine: "postgresql"
    queries: "queries/"
    schema: "schema.sql"
    gen:
      go:
        package: "db"
        out: "db"
        emit_json_tags: true
        emit_prepared_queries: false
        emit_interface: true
        emit_exact_table_names: false

SCHEMA (schema.sql):

CREATE TABLE users (
  id         BIGSERIAL PRIMARY KEY,
  email      TEXT NOT NULL UNIQUE,
  name       TEXT NOT NULL,
  created_at TIMESTAMP NOT NULL DEFAULT NOW()
);

CREATE TABLE posts (
  id         BIGSERIAL PRIMARY KEY,
  user_id    BIGINT NOT NULL REFERENCES users(id),
  title      TEXT NOT NULL,
  content    TEXT NOT NULL,
  created_at TIMESTAMP NOT NULL DEFAULT NOW()
);

QUERIES (queries/users.sql):

-- name: GetUser :one
SELECT * FROM users
WHERE id = $1 LIMIT 1;

-- name: ListUsers :many
SELECT * FROM users
ORDER BY created_at DESC;

-- name: CreateUser :one
INSERT INTO users (email, name)
VALUES ($1, $2)
RETURNING *;

-- name: UpdateUser :exec
UPDATE users
SET name = $2
WHERE id = $1;

-- name: DeleteUser :exec
DELETE FROM users WHERE id = $1;

-- name: GetUserWithPosts :many
SELECT
  users.id, users.name, users.email,
  posts.id AS post_id, posts.title, posts.content
FROM users
LEFT JOIN posts ON posts.user_id = users.id
WHERE users.id = $1;

GENERAR:

//go:generate sqlc generate

O:
sqlc generate

CÓDIGO GENERADO (db/querier.go):

type Querier interface {
    GetUser(ctx context.Context, id int64) (User, error)
    ListUsers(ctx context.Context) ([]User, error)
    CreateUser(ctx context.Context, arg CreateUserParams) (User, error)
    UpdateUser(ctx context.Context, arg UpdateUserParams) error
    DeleteUser(ctx context.Context, id int64) error
}

USAR:

import "github.com/myapp/db"

queries := db.New(dbConn)

// Get user
user, err := queries.GetUser(ctx, 123)

// Create user
user, err := queries.CreateUser(ctx, db.CreateUserParams{
    Email: "alice@example.com",
    Name:  "Alice",
})

// List users
users, err := queries.ListUsers(ctx)

// Update
err := queries.UpdateUser(ctx, db.UpdateUserParams{
    ID:   123,
    Name: "Alice Updated",
})

// Delete
err := queries.DeleteUser(ctx, 123)

TRANSACTIONS:

func CreateUserWithPost(ctx context.Context, db *sql.DB, email, name, title string) error {
    queries := db.New(db)

    tx, _ := db.Begin()
    defer tx.Rollback()
    qtx := queries.WithTx(tx)

    user, err := qtx.CreateUser(ctx, db.CreateUserParams{
        Email: email,
        Name:  name,
    })
    if err != nil {
        return err
    }

    _, err = qtx.CreatePost(ctx, db.CreatePostParams{
        UserID:  user.ID,
        Title:   title,
        Content: "",
    })
    if err != nil {
        return err
    }

    return tx.Commit()
}`)
	// ============================================
	// CUSTOM GENERATORS
	// ============================================
	fmt.Println("\n--- Custom Generators ---")
	fmt.Println(`
TEMPLATE-BASED GENERATOR:

// gen.go
//go:build ignore

package main

import (
    "os"
    "text/template"
)

const tmpl = ` + "`" + `// Code generated by gen.go; DO NOT EDIT.

package {{.Package}}

type {{.Name}} struct {
{{range .Fields}}    {{.Name}} {{.Type}} ` + "`json:\"{{.JSONName}}\"`\n{{end}}" + `}
` + "`" + `

type Field struct {
    Name     string
    Type     string
    JSONName string
}

type Model struct {
    Package string
    Name    string
    Fields  []Field
}

func main() {
    model := Model{
        Package: "models",
        Name:    "User",
        Fields: []Field{
            {Name: "ID", Type: "string", JSONName: "id"},
            {Name: "Name", Type: "string", JSONName: "name"},
            {Name: "Email", Type: "string", JSONName: "email"},
        },
    }

    t := template.Must(template.New("model").Parse(tmpl))
    f, _ := os.Create("user_generated.go")
    defer f.Close()
    t.Execute(f, model)
}

// Directiva
//go:generate go run gen.go

EMBED TEMPLATE:

//go:embed templates/model.tmpl
var modelTemplate string

func Generate() {
    t := template.Must(template.New("model").Parse(modelTemplate))
    // ...
}`)
	// ============================================
	// AST MANIPULATION
	// ============================================
	fmt.Println("\n--- AST Manipulation ---")
	os.Stdout.WriteString(`
PARSEAR CÓDIGO GO:

import (
    "go/ast"
    "go/parser"
    "go/token"
)

func ParseFile(filename string) (*ast.File, error) {
    fset := token.NewFileSet()
    f, err := parser.ParseFile(fset, filename, nil, parser.ParseComments)
    return f, err
}

VISITOR PATTERN:

type Visitor struct{}

func (v *Visitor) Visit(node ast.Node) ast.Visitor {
    if node == nil {
        return nil
    }

    switch n := node.(type) {
    case *ast.FuncDecl:
        fmt.Printf("Function: %s\n", n.Name.Name)
    case *ast.TypeSpec:
        fmt.Printf("Type: %s\n", n.Name.Name)
    case *ast.StructType:
        fmt.Println("Struct found")
    }

    return v
}

// Usar
ast.Walk(&Visitor{}, f)

INSPECT (más simple):

ast.Inspect(f, func(n ast.Node) bool {
    funcDecl, ok := n.(*ast.FuncDecl)
    if ok {
        fmt.Printf("Function: %s\n", funcDecl.Name.Name)
    }
    return true
})

ENCONTRAR STRUCTS CON TAGS:

func FindStructsWithJSONTags(filename string) {
    fset := token.NewFileSet()
    f, _ := parser.ParseFile(fset, filename, nil, 0)

    ast.Inspect(f, func(n ast.Node) bool {
        typeSpec, ok := n.(*ast.TypeSpec)
        if !ok {
            return true
        }

        structType, ok := typeSpec.Type.(*ast.StructType)
        if !ok {
            return true
        }

        fmt.Printf("Struct: %s\n", typeSpec.Name.Name)

        for _, field := range structType.Fields.List {
            if field.Tag != nil {
                tag := field.Tag.Value
                if strings.Contains(tag, "json") {
                    for _, name := range field.Names {
                        fmt.Printf("  Field: %s, Tag: %s\n", name.Name, tag)
                    }
                }
            }
        }

        return true
    })
}

GENERAR CÓDIGO CON AST:

import (
    "go/ast"
    "go/format"
    "go/token"
)

func GenerateStruct(name string, fields map[string]string) string {
    // Crear AST
    f := &ast.File{
        Name: ast.NewIdent("main"),
        Decls: []ast.Decl{
            &ast.GenDecl{
                Tok: token.TYPE,
                Specs: []ast.Spec{
                    &ast.TypeSpec{
                        Name: ast.NewIdent(name),
                        Type: &ast.StructType{
                            Fields: makeFields(fields),
                        },
                    },
                },
            },
        },
    }

    // Formatear
    var buf bytes.Buffer
    format.Node(&buf, token.NewFileSet(), f)
    return buf.String()
}

func makeFields(fields map[string]string) *ast.FieldList {
    var list []*ast.Field
    for name, typ := range fields {
        list = append(list, &ast.Field{
            Names: []*ast.Ident{ast.NewIdent(name)},
            Type:  ast.NewIdent(typ),
        })
    }
    return &ast.FieldList{List: list}
}

GOIMPORTS/GOFMT:

import "golang.org/x/tools/imports"

func FormatCode(source []byte) ([]byte, error) {
    return imports.Process("", source, nil)
}

JENNIFER (Code generation library):

go get github.com/dave/jennifer/jen

import "github.com/dave/jennifer/jen"

f := jen.NewFile("main")

f.Func().Id("main").Params().Block(
    jen.Qual("fmt", "Println").Call(jen.Lit("Hello, World!")),
)

fmt.Printf("%#v", f)

// Generar struct
f.Type().Id("User").Struct(
    jen.Id("ID").String().Tag(map[string]string{"json": "id"}),
    jen.Id("Name").String().Tag(map[string]string{"json": "name"}),
)
`)

	// ============================================
	// MAKEFILE INTEGRATION
	// ============================================
	fmt.Println("\n--- Makefile Integration ---")
	fmt.Println(`
.PHONY: generate
generate:
	go generate ./...
	gofmt -s -w .
	goimports -w .

.PHONY: mocks
mocks:
	mockgen -source=internal/service/user.go -destination=internal/service/mock/user.go

.PHONY: proto
proto:
	protoc --go_out=. --go-grpc_out=. proto/*.proto

.PHONY: sqlc
sqlc:
	sqlc generate

.PHONY: stringer
stringer:
	stringer -type=Status -output=status_string.go

.PHONY: all
all: generate mocks proto sqlc
	go build ./...`)
	// Demostración conceptual
	demonstrateCodeGeneration()
}

func demonstrateCodeGeneration() {
	fmt.Printf("\n--- Demostración Conceptual ---\n")
	fmt.Printf("Herramientas de generación:\n")
	fmt.Printf("  stringer: String() para enums\n")
	fmt.Printf("  mockgen: Mocks para testing\n")
	fmt.Printf("  protoc: Protocol Buffers\n")
	fmt.Printf("  sqlc: Type-safe SQL\n")
	fmt.Printf("  AST: Manipulación de código\n")
	fmt.Printf("\nBeneficios:\n")
	fmt.Printf("  - Type-safety\n")
	fmt.Printf("  - Reduce boilerplate\n")
	fmt.Printf("  - Menos errores\n")
	fmt.Printf("  - Mantiene sincronía\n")
}

/*
RESUMEN DE CODE GENERATION:

GO GENERATE:
- Directiva: //go:generate command args
- Variables: $GOFILE, $GOPACKAGE, $GOLINE
- Ejecutar: go generate ./...
- Convención: *_gen.go, *_generated.go

STRINGER:
- Comando: stringer -type=EnumType
- Genera: String() method
- -linecomment para nombres custom
- -trimprefix para quitar prefijo

MOCKGEN:
- go.uber.org/mock/mockgen
- Modo source: -source=file.go
- Modo reflect: package Interface
- EXPECT() para expectativas
- gomock.Any(), gomock.Eq(), etc

PROTOC:
- protoc --go_out --go-grpc_out
- Genera: .pb.go y _grpc.pb.go
- buf como alternativa moderna
- Proto3 syntax

SQLC:
- Type-safe SQL queries
- Genera: structs, queries, interface
- Annotations: :one, :many, :exec
- Soporta: PostgreSQL, MySQL, SQLite
- Transactions: WithTx()

CUSTOM GENERATORS:
- text/template
- go/ast parsing
- go/format output
- jennifer library

AST MANIPULATION:
- go/parser: ParseFile()
- go/ast: Walk(), Inspect()
- go/token: FileSet
- go/format: Node()
- go/printer: Fprint()

MEJORES PRÁCTICAS:
1. Siempre incluir "DO NOT EDIT" comment
2. Usar convenciones: *_gen.go
3. .gitignore para archivos generados (opcional)
4. Commit código generado para reproducibilidad
5. go generate en CI/CD
6. Makefile para orquestar
7. Verificar con go vet
8. Tests para generadores

INTEGRACIÓN CI/CD:
# .github/workflows/generate.yml
- run: go generate ./...
- run: git diff --exit-code

VENTAJAS:
- Type-safety
- Reduce boilerplate
- Sincronización automática
- Menos errores manuales
- Consistencia
- DRY principle

DESVENTAJAS:
- Setup inicial complejo
- Build time aumenta
- Debugging más difícil
- Dependencias adicionales
*/
